# 基础

## 面向对象和面向过程的区别

面向过程：用函数一步一步的实现需求，需要的时候进行调用

面向对象：把问题分为多个对象，建立对象也是为了描述事物解决问题的过程发生的行为；面向对象有**封装、集成、多态**的特性；易维护、复用、扩展



## 线程、程序、进程的基本概念。以及他们之间关系

简单的来说，程序是静态的代码集合，进程是程序的执行实例，而线程是进程内部的执行单元

关系是程序被加载到内存中执行后，会创建一个进程，进程内部可以包含一个或多个线程，线程共享进程的资源



## 重写和重载区别

重写：

1. 子类集成父类或实现接口（对方法的重写）
2. 方法名、参数列表、返回类型 必须相同
3. 子类方法修饰符 > 被重写的方法修饰符
4. 不能抛出新的异常

重载

同类中，同名的方法不同参数；类型不同，个数不同；对返回类型无要求



## == 和 equal

== 变量在“栈”里面，对象在“堆”里面；两端比较的是内存中的地址

equals 比较的是两个对象的内容是否相等；一般将常量写在左侧



## Java创建对象有几种方式

1. new创建新对象
2. 通过反射机制
3. 采用clone机制
4. 通过序列化机制



## String、StringBuffer 和 StringBuilder区别

String 是只读字符串，是一个对象，被final修饰的字符数组，被引用的字符串不能被改变，因此每次对String的操作都会生成新的String对象

StringBuffer 和 StringBuilder都继承于了AbstractStringBuilder抽象类

底层都是可变的字符数组，对字符串频繁操作建议用StringBuffer 和 StringBuilder

StringBuffer 加了同步锁，因此线程安全；而StringBuilder则没有对此操作，因此线程不安全，但效率相当于StringBuffer 高



## 有数组了为什么还要搞个 ArrayList

在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了

而 ArrayList 可以使用默认的大小，当元素个数到达一定程度 后，会自动扩容



## ArrayList和linkedList的区别

ArrayList 基于数组实现，数组则是基于索引数据结构，因此搜索和读取比较快；删除开销大，因为需要对数组中所有数据进行重排

linkedList 是一个双向链表，在添加和删除更优，查询弱于ArrayList （基本是指数据量大时）



父类不同

1. arraylist <--- abstractLIst < --- collection
2. linkedList <--- abstractSquentialList < ---abstractList <--- collection



## List,Set,Map三者的区别

- List：
  - 是一个有序集合，可以包含重复元素
  - 按照插入顺序访问元素，并且可以通过索引进行随机访问
  - 通过索引查找快，增删速度慢
- Set：
  - 不允许包含重复元素的集合
  - 保证元素的顺序
  - 检索元素效率低下，删除和插入效率高
- Map：
  - 是一个键值对的集合，每个键都唯一
  - 键是不可重复的，但值可以重复
  - 不保证键值对的顺序



## HashMap和HashTable的区别

1. 父类不同
   1. HashMap是继承自AbstractMap类
   2. 而Hashtable是继承自Dictionary类。
2. 对null的支持不同
   1. Hashtable：key和value都不能为null
   2. HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个 key值对应的value为null。
3. 安全性不同
   1. HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题
   2. Hashtable是线程安全的，它的每个方法上都有synchronized 关键字
   3. ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为 ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。
4. 初始容量大小和每次扩充容量大小不同
   1. HashMap初始容量为16，当容量为16*0.75时，每次扩容是原容量的两倍
   2. HashTable初始容量为11，当容量为11*0.75时，每次扩容是原容量的两倍+1
5. 计算hash值的方法不同
   1. HashMap和HashTable都是通过调用键对象的`hashCode()`方法来计算哈希码，但是HashTable还会进行额外的处理以确保哈希码为正数



## HashMap 的长度为什么是 2 的 N 次方呢

为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞

也就是说尽量把数 据能均匀的分配，每个链表或者红黑树长度尽量相等

```
取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说
hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进
制位操作 & ，相对于 % 能够提高运算效率
```



## HashMap 与 ConcurrentHashMap 的异同

1. 都是 key-value 形式的存储
2.  HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的
3.  HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑 树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红 黑树查询速度快
4. HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩 容；
5. ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry
   1. Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized 来保证并发安全进行实现



## SynchronizedMap和ConcurrentHashMap有什么区别

**SynchronizedMap**：通过Collections工具类提供的静态方法`Collections.synchronizedMap()`来创建的，通过在每个方法上添加`synchronized`关键字来实现同步

**ConcurrentHashMap**： 使用分段锁（Segment），将整个Map分成多个Segment，每个Segment拥有自己的锁，不同Segment的数据可以并发读写





## 红黑树有哪几个特征

- 每个节点是 黑色或红色
- 根节点是黑色
- 每个叶子节点都是黑色(指向空的叶子节点)
- 如果一个叶子节点是红色，那么其子节点必须都是黑色的
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点



##  Java的四种引用，强弱软虚

强引用

平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收

```java
String str = new String("str");
System.out.println(str);
```



弱引用

弱引用就是只要JVM垃圾回收器发现了它，就会将之回收

```
WeakReference<String> wrf = new WeakReference<String>(str);
```



软引用

软引用在程序内存不足时，会被回收

```java
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```



虚引用

虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中

```java
PhantomReference<String> prf = new PhantomReference<String>(new String("str"),
new ReferenceQueue<>());
```



## 深拷贝和浅拷贝的区别

浅拷贝 仅复制对象本身，而不复制对象内部的引用类型成员

深拷贝 不仅复制对象本身，还会递归地复制对象内部的引用类型成员



## final，finally和finalize区别

- **final**
  - `final`用于修饰类时，表示该类不能被继承
  - `final`用于修饰方法时，表示该方法不能被子类重写
  - `final`用于修饰变量时，表示该变量的值只能被赋值一次，即为常量
- **finaly**
  - `finally`是一个关键字，用于定义在try-catch语句中的代码块。无论异常是否被捕获，`finally`块中的代码都会被执行
- **finalize**
  - `inalize`是Object类中的一个方法，用于在对象被垃圾回收前执行清理操作



## Java 序列化中如果有些字段不想进行序列化

对于不想进行序列化的变量，使用 transient 关键字修饰。



##  IO 流

- 按照流的流向分，可以分为输入流和输出流； 
- 按照操作单元划分，可以划分为字节流和字符流；



- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。



## IO与 NIO的区别

是Java中用于处理输入和输出的API

IO：IO是基于流（Stream）的模型，它使用阻塞式I/O（Blocking I/O）来处理输入和输出

NIO：NIO是基于通道（Channel）和缓冲区（Buffer）的模型，它使用非阻塞式I/O来处理输入和输出



NIO相比于传统IO具有更好的性能和可扩展性，特别是在处理大量并发连接时。

传统IO适合于较少的连接数和简单的应用程序，而NIO适用于需要处理大量并发连接和高性能的网络应用程序





## 实现多线程有几种方法

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口（ JDK1.5>= ）
4. 线程池方式创建



### 实现Runnable、Callable接口的方式创建线程的优缺点

**Runnable**

- 优点：线程类只是实现了Runnable或者Callable接口，还可以继承其他类
- 缺点：编程稍微复杂一些，如果需要访问当前线程，则必须使用 Thread.currentThread() 方法

****

**Callable**

- 优点：：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this即可获取当前线程

- 缺点：：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了



## 如何停止一个正在运行的线程

1. 使用退出标志
2. 使用stop方法强行终止
3. 使用interrupt方法中断线程



## notify()和notifyAll()区别

**notify**：用于唤醒在当前对象上等待的单个线程；可能会导致死锁；

​	如果有多个线程在当前对象上调用了`wait()`方法进入等待状态，那么只有一个线程会被唤醒，但是哪一个线程被唤醒是不确定的。

**notifyAll**：用于唤醒在当前对象上等待的所有线程；不会导致死锁



## sleep()和wait()区别

**sleep**：属于Thread类；不会释放锁；时间到会⾃动恢复

**wait**：属于Object类；会释放当前线程持有的对象锁；需使⽤ notify()/notifyAll()直接唤醒





## Thread 类中的start() 和 run() 方法区别

start()方法被用来启动新创建的线程，执行内部调用了run()方法；



## 有三个线程T1,T2,T3,如何保证顺序执行

可以用线程类的join()方法在一个线程中启动另一 个线程另外一个线程完成该线程继续执行。

为了确保三个线程的顺序你应该先启动最后一个(T3调 用T2，T2调用T1)，这样T1就会先完成而T3最后完成

```java
Thread T1 = new Thread(() -> {
    // T1的任务
});

Thread T2 = new Thread(() -> {
    try {
        T1.join(); // 等待T1执行完成
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // T2的任务
});

Thread T3 = new Thread(() -> {
    try {
        T2.join(); // 等待T2执行完成
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // T3的任务
});

T1.start();
T2.start();
T3.start();

```



## Thread类中的yield方法有什么作用

法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行



## 线程池中submit() 和 execute()方法有什么区别

**execute**： 定义在Executor接口中，execute()方法的返回类型是void

**submit**： 定义在ExecutorService接口中，返回持有计算结果的Future对象



## 对线程池的理解

1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性；如果无限制的创建，不仅会消耗系统资源，还会降 低系统的稳定性



## 常用的线程池

- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按 照任务的提交顺序执行。 
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线 程达到线程池的最大大小。
-  newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线 程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 
- newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行 任务的需求。 
- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任 务的需求



## 产生死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用 
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放 
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系



## 如何避免死锁

指定获取锁的顺序

比如只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可 以避免死锁！



## 线程安全需要保证几个基本特征

- 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。 
- 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将 线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
- 有序性，是保证线程内串行语义，避免指令重排等



## ThreadLocal原理

**内部实现**

- 对象内部都包含了一个ThreadLocalMap对象
- ThreadLocalMap是一个自定义的散列表，它的键是ThreadLocal对象，值是对应线程的变量副本
- ThreadLocal的`get()`；获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后从Map中根据ThreadLocal对象获取变量副本
- ThreadLocal的`set()`方法；先获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后将ThreadLocal对象和变量副本存入Map中
- ThreadLocal的`remove()`方法；获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后从Map中移除对应的键值对。



**线程间隔离**

- 每个线程都拥有自己的ThreadLocalMap对象，不同线程之间的变量副本相互独立，互不影响
- 创建ThreadLocal对象并设置变量值时，只有当前线程可以访问该变量，其他线程无法访问
- 即使是相同的ThreadLocal对象，不同线程之间的变量副本也是独立的





# spring

## 什么是spring

Spring 是一个轻量级的IoC和AOP容器框架。用于简化企业应用程序的开发

有以下优点：

- 轻量：Spring 是轻量的，基本的版本大约2MB。
- 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找 依赖的对象们
-  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
- 容器：Spring 包含并管理应用中对象的生命周期和配置。
- MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
- 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务
- 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛 出的）转化为一致的unchecked 异常



有以下核心模块：

- Spring Core：核心类库，提供IOC服务；
- Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；
- Spring AOP：AOP服务； Spring DAO：对JDBC的抽象，简化了数据访问异常的处理
- Spring ORM：对现有的ORM框架的支持
- Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；
- Spring MVC：提供面向Web应用的Model-View-Controller实现。



##  Autowired和Resource关键字的区别

@Resource和@Autowired都是做bean的注入时使用

@Resource并不是Spring的注解，是java的原生注解；按照ByName自动注入

@Autowired为Spring提供的注解；按照类型（byType）装配依赖对象



## 依赖注入的几种方式

1. 构造器注入
2. setter注入
3. 接口注入





## 对Spring MVC的理解

是spring在原 有基础上，又提供了web应用的MVC模块

可以简单的把springMVC理解为是spring的一个模块



MVC模式

MVC：MVC是一种设计模式

- M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）
- V-View 视图（做界面的展示 jsp，html……）
- C-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）

![image-20240527234219674](C:\Users\f\Documents\面试题\assets\image-20240527234219674.png)

```
1、 用户发送请求至前端控制器DispatcherServlet。
2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器
拦截器(如果有则生成)一并返回给DispatcherServlet。
4、 DispatcherServlet调用HandlerAdapter处理器适配器。
5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6、 Controller执行完成返回ModelAndView。
7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9、 ViewReslover解析后返回具体View。
10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11、 DispatcherServlet响应用户。
```



## SpringMVC常用的注解

- @RequestMapping
- @RequestBody
- @ResponseBody



## 对Spring的AOP理解

AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所 共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复 代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。



Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK 动态代理去创建代理对象

而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib 动态代理生成一个被代理对象的子类来作为代理





## 对Spring的IOC理解

IOC就是控制反转，是指创建对象的控制权的转移。

最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反 射机制

Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。



## spring bean的生命周期

实例化

初始init

接收请求service

销毁destroy



## Spring支持的几种bean的作用域

- singleton：默认单例
- prototype：为每一个bean请求提供一个实例
- request：为每一个网络请求创建一个实例；在请求完成以后，bean会失效并被垃圾回收器回收
- session：与request范围类似，确保每个session中有一个bean的实例，在session过期后， bean会随之失效。
- global-session：全局作用域



## Spring框架中都用到了哪些设计模式

- 简单工厂模式
  - Spring 中的 BeanFactory 就是简单工厂模式的体现
- 工厂模式
  - Spring 中的 FactoryBean 就是典型的工厂方法模式
- 单例模式
  - 在 spring 中（作用域）用到的单例模式有： scope="singleton" ，注册式单例模式，bean 存放于 Map 中。bean name 当做 key，bean 当做 value。
- 原型模式
  - 在 spring 中用到的原型模式有： scope="prototype" ，每次获取的是通过克隆生成的新实例
- 代理模式
  - Spring 中经典的 AOP，就是使用动态代理实现的，分 JDK 和 CGlib 动态代理
- 适配器模式
  - Spring 中的 AOP 中 AdvisorAdapter 类
- 观察者模式
  - Spring 中的 Event 和 Listener
    - ApplicationEvent，该抽象类继承了 EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。
    - ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承 EventListener
- 模板模式
  - JdbcTemplate 就是非常经典的模板模式 的应用，里面的 execute 方法，把整个算法步骤都定义好了
- 责任链模式
  - DispatcherServlet 中的 doDispatch() 方法中获取与请求匹配的处理器 HandlerExecutionChain，this.getHandler() 方法的处理使用到了责任链模式



## Spring 中 ApplicationContext 和 BeanFactory 的区别

- 所属包不同
  - BeanFactory在spring-beans.jar
  - ApplicationContext在spring-context.jar
- 国际化
  - BeanFactory 不支持国际化，没有实现MessageResource
  - ApplicationContext 却可以
- 事件机制
  - ApplicationContext事件机制是观察者设计模式的 实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。 如果容器中有一个ApplicationListener Bean，每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发
- 底层资源的访问
  - ApplicationContext 扩展了 ResourceLoader（资源加载器）接口，从而可以用来加载多个 Resource
  - BeanFactory 是没有扩展 ResourceLoader
- 创建方式
  - BeanFactory 通常以编程的方式被创建
  - ApplicationContext 能以声明的方式创建，也可以使用编程的方式
    - 编程式：通过代码new的方式
    - 声明式：通过配置文件或注解的方式
- 延迟加载
  - BeanFactroy 采用的是延迟加载形式来注入 Bean ；只有在使用时才会具体实例化bean
  - ApplicationContext 是容器启动时就创建所有bean



## Spring 框架中的单例 Bean 是线程安全的么

spring 中的 bean 默认是[单例](https://so.csdn.net/so/search?q=单例模式&spm=1001.2101.3001.7020)的；框架并没有对单例 bean 进行多线程的封装处理

某种程度上来说 bean 也是安全的；但如果 Bean 内部存在可变状态，开发者需要自行确保线程安全性



## Spring 是怎么解决循环依赖的

A依赖B；B依赖A

自我依赖

A依赖B；B依赖C；C依赖A；

使用三级缓存，就用用来存放不同类型的bean

一级缓存，存放的是完全初始化好的bean，可以直接使用

二级缓存，存放的原始bean，其里面的属性还没被赋值

三级缓存，存放的是bean工厂对象，生成原始bean对象，并放入二级缓存



主要是把bean的实例化，bean的属性注入分离出来



![image-20240529225649169](C:\Users\f\Documents\面试题\assets\image-20240529225649169.png)



- 多实例的Setter注入导致的循环依赖，需要把Bean改成单例。
- 构造器注入导致的循环依赖，可以通过@Lazy注解
- DependsOn注解： 使用@DependsOn注解指定依赖项的加载顺序，以避免出现循环依赖问题
- 重新设计





## 解决依赖冲突的方法

- 情况一：项目依赖了同一Jar包的多个版本，并且选错了版本；
- 情况二：同样的类在不同的Jar包中出现，导致JVM加载了错误的类；



- Maven：在命令行中执行mvn dependency:tree，查看项目的依赖树，找出冲突的依赖；在pom.xml中使用标签来排除冲突的依赖版本。
- 设置 classpath 指定jar包加载的先后顺序



## 事务三要素

- 数据源：表示具体的事务性资源，是事务的真正处理者，如MySQL等。
- 事务管理器：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。
- 事务应用和属性配置：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属 性如隔离级别、超时时间等。



## 事务的隔离级别

- 未提交读(Read Uncommitted)：可读取到事务未提交的数据，隔离性差，会出现脏读，不可重复读，幻读问题
  - 脏读：在一个事务中，修改数据还没提交，就被另一个事务读取到了；产生错误是数据
  - 不可重复读：在一个事务中，两次读取同一数据却得到了不同的结果；可能是因为在两次读取之间另一个事务修改了数据并且提交了
  - 幻读：在一个事务中，两次查询同一个范围的数据，但是得到了不同数量的行。这是因为在两次查询过程中有另外一个事务插入数据造成的。
    - 不可重复读是在同一个数据行上发生的，而幻读是在一个数据范围上发生的
    - 不可重复读是由于并发事务中的数据更新导致的，而幻读则是由于并发事务中的数据插入导致的
- 已提交读(Read Committed)：可读取到事务已提交的数据，隔离性一般，不会出现脏读问题，但是会出现不可重复读，幻读问题
- 可重复读(Repeated Read)：可防止脏读（当前内存读），防止不可重复读问题，防止会出现的幻读问题，但是并发能力较差
- 可串行化(Serializable)：隔离性比较高，可以实现串行化读取数据，但是事务的并发度就没有了；这是事务的最高级别，在每条读的数据上，加上锁，使之不可能相互冲突





## 事务的传播级别

**Spring事务定义了7种传播机制**



- PROPAGATION_REQUIRED:默认的Spring事物传播级别，若当前存在事务，则加入该事务，若 不存在事务，则新建一个事务。
- PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建 一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交
- PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务， 则新建一个事务
- PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行
- PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂 起
- PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常
- PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。



##  Spring框架的事务管理优点

为不同的的事务API提供了统一的编程模型。





# MyBatis

## 什么是MyBatis

Mybatis是一个半ORM框架，内部封装了JDBC，开发时只需要关注SQL 语句本身；不用花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，直接编写原生sql就是

可以用过xml或注解映射信息，将 POJO映射成数据库中的记录，避免手动设置参数或获取结果集



## MyBatis的优点和缺点

- 优点

  - 基于SQL语句编程，相当灵活，便于统一管理，支持动态sql

  - 相对比原生jdbc，代码量减少了很多；不需要手动开关连接
  - 支持映射标签，支持对象关系组件维护

- 缺点

  - sql工作量较大，特别是字段多的时候



## \#{}和${}的区别

\#{}是预编译处理；${}是字符串替换

- Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；
- Mybatis在处理${}时，就是把${}替换成变量的值。
- 使用#{}可以有效的防止SQL注入，提高系统安全性。



## 当实体类中的属性名和表中的字段名不一样 

1. 在sql中定义别名
2. 使用property定义属性名，column定义列名



## Mybatis是如何进行分页的？分页插件的原理是什么

Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页

基本原理是使用Mybatis提供的插件接口；实现自定义插件，在插件的拦截方法内拦截 待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数



## Mybatis是否支持延迟加载？如果支持，它的实现原理是什么

仅支持association关联对象和collection关联集合对象的延迟加载

- association指的就是一 对一
- collection指的就是一对多查询
- 可以配置是否启用延迟加载 lazyLoadingEnabled=true|false



原理

> 使用CGLIB创建目标对象的代理对象，调用方法时，进入拦截器方法；比如a.getB().getName()
>
> 拦截器invoke发现getB()是null，就会单独发送先保存好的管理B对象的sql，把B查询出，如何调用set赋值进去
>
> 接着完成a.getB().getName()调用



> 使用CGLIB创建目标对象的代理对象，当访问代理对象的方法时，代理逻辑会检查对应的数据是否已经加载。如果还没有加载，代理对象会执行实际的查询操作来加载数据
>
> 在执行业务代码时，当第一次访问代理对象的某个属性或方法时，MyBatis 会触发懒加载，执行必要的SQL查询并填充代理对象的数据
>
> 一旦触发懒加载，MyBatis 将调用相应的 Mapper 接口和 SQL 映射，执行数据库查询并获取数据。获取的数据随后填充到代理对象中，替换原来的懒加载占位



## Mybatis的缓存机制

### 一级缓存

> 在运行过程中，可能在一次数据库会话中，执行多次查询条件完全相同的 SQL；如果是相同的 SQL 语句，会优先命中一级缓存， 避免直接对数据库进行查询，提高性能
>
> 一级缓存的生命周期和 SqlSession 一致
>
> 一级缓存内部设计简单，只是一个没有容量限定的 HashMap



#### 什么时候一级缓存失效

> sqlSession的clearCache()方法，手动清空缓存
>
> 执行了INSERT或DELETE或UPDATE语句。不管你是操作哪张表的，都会清空一级缓存



### 二级缓存

**前置条件**

> 开启二级缓存：cacheEnabled为true；开启后CachingExecutor会修饰Executor；进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询
>
> 对应xml中添加<cache/>标签；对应的mapper标签中想要设置namespace
>
> ⼆级缓存的实体类对象**必须是可序列化**；也就是必须实现Serializable
>
> **SqlSession对象关闭或提交**之后，⼀级缓存中的数据才会被写⼊到⼆级缓存当中。此时⼆级缓存才可⽤



> 从一级缓存中看，的共享范围就是一个 SqlSession 内部，如果多个 SqlSession 之间需要共享缓存，则需要使用到二级缓存
>
> 二级缓存是 `namespace` 级别的缓存。一级缓存是默认开启的，而二级缓存需要手动开启
>
> 查询语句执行时，MyBatis 会首先尝试从二级缓存中查找对应的数据
>
> 缓存中存在数据，则直接返回缓存中的数据
>
> 如果缓存中不存在数据，则执行数据库查询，并将查询结果存入缓存
>
> 如果其他 SqlSession 对同样的查询进行了修改，那么会触发缓存的失效，使得下次查询会重新从数据库中获取数据



![image-20240530012926071](C:\Users\f\Documents\面试题\assets\image-20240530012926071.png)



**二级缓存失效**

只要两次查询之间出现了增删改操作。⼆级缓存就会失效。【⼀级缓存也会失效】



## MyBatis 中比如 UserMapper.java 是接口，为什么没有实现类还能调用

使用JDK动态代理+MapperProxy。本质上调用的是MapperProxy的invoke方法