# 基础

## 面向对象和面向过程的区别

面向过程：用函数一步一步的实现需求，需要的时候进行调用

面向对象：把问题分为多个对象，建立对象也是为了描述事物解决问题的过程发生的行为；面向对象有**封装、集成、多态**的特性；易维护、复用、扩展



## 线程、程序、进程的基本概念。以及他们之间关系

简单的来说，程序是静态的代码集合，进程是程序的执行实例，而线程是进程内部的执行单元

关系是程序被加载到内存中执行后，会创建一个进程，进程内部可以包含一个或多个线程，线程共享进程的资源



## 重写和重载区别

重写：

1. 子类集成父类或实现接口（对方法的重写）
2. 方法名、参数列表、返回类型 必须相同
3. 子类方法修饰符 > 被重写的方法修饰符
4. 不能抛出新的异常

重载

同类中，同名的方法不同参数；类型不同，个数不同；对返回类型无要求



## == 和 equal

== 变量在“栈”里面，对象在“堆”里面；两端比较的是内存中的地址

equals 比较的是两个对象的内容是否相等；一般将常量写在左侧



## Java创建对象有几种方式

1. new创建新对象
2. 通过反射机制
3. 采用clone机制
4. 通过序列化机制



## String、StringBuffer 和 StringBuilder区别

String 是只读字符串，是一个对象，被final修饰的字符数组，被引用的字符串不能被改变，因此每次对String的操作都会生成新的String对象

StringBuffer 和 StringBuilder都继承于了AbstractStringBuilder抽象类

底层都是可变的字符数组，对字符串频繁操作建议用StringBuffer 和 StringBuilder

StringBuffer 加了同步锁，因此线程安全；而StringBuilder则没有对此操作，因此线程不安全，但效率相当于StringBuffer 高



## 有数组了为什么还要搞个 ArrayList

在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了

而 ArrayList 可以使用默认的大小，当元素个数到达一定程度 后，会自动扩容



## ArrayList和linkedList的区别

ArrayList 基于数组实现，数组则是基于索引数据结构，因此搜索和读取比较快；删除开销大，因为需要对数组中所有数据进行重排

linkedList 是一个双向链表，在添加和删除更优，查询弱于ArrayList （基本是指数据量大时）



父类不同

1. arraylist <--- abstractLIst < --- collection
2. linkedList <--- abstractSquentialList < ---abstractList <--- collection



## List,Set,Map三者的区别

- List：
  - 是一个有序集合，可以包含重复元素
  - 按照插入顺序访问元素，并且可以通过索引进行随机访问
  - 通过索引查找快，增删速度慢
- Set：
  - 不允许包含重复元素的集合
  - 保证元素的顺序
  - 检索元素效率低下，删除和插入效率高
- Map：
  - 是一个键值对的集合，每个键都唯一
  - 键是不可重复的，但值可以重复
  - 不保证键值对的顺序



## HashMap和HashTable的区别

1. 父类不同
   1. HashMap是继承自AbstractMap类
   2. 而Hashtable是继承自Dictionary类。
2. 对null的支持不同
   1. Hashtable：key和value都不能为null
   2. HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个 key值对应的value为null。
3. 安全性不同
   1. HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题
   2. Hashtable是线程安全的，它的每个方法上都有synchronized 关键字
   3. ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为 ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。
4. 初始容量大小和每次扩充容量大小不同
   1. HashMap初始容量为16，当容量为16*0.75时，每次扩容是原容量的两倍
   2. HashTable初始容量为11，当容量为11*0.75时，每次扩容是原容量的两倍+1
5. 计算hash值的方法不同
   1. HashMap和HashTable都是通过调用键对象的`hashCode()`方法来计算哈希码，但是HashTable还会进行额外的处理以确保哈希码为正数



## HashMap 的长度为什么是 2 的 N 次方呢

为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞

也就是说尽量把数 据能均匀的分配，每个链表或者红黑树长度尽量相等

```
取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说
hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进
制位操作 & ，相对于 % 能够提高运算效率
```



## HashMap 与 ConcurrentHashMap 的异同

1. 都是 key-value 形式的存储
2.  HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的
3.  HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑 树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红 黑树查询速度快
4. HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩 容；
5. ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry
   1. Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized 来保证并发安全进行实现



## SynchronizedMap和ConcurrentHashMap有什么区别

**SynchronizedMap**：通过Collections工具类提供的静态方法`Collections.synchronizedMap()`来创建的，通过在每个方法上添加`synchronized`关键字来实现同步

**ConcurrentHashMap**： 使用分段锁（Segment），将整个Map分成多个Segment，每个Segment拥有自己的锁，不同Segment的数据可以并发读写





## 红黑树有哪几个特征

- 每个节点是 黑色或红色
- 根节点是黑色
- 每个叶子节点都是黑色(指向空的叶子节点)
- 如果一个叶子节点是红色，那么其子节点必须都是黑色的
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点



##  Java的四种引用，强弱软虚

强引用

平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收

```java
String str = new String("str");
System.out.println(str);
```



弱引用

弱引用就是只要JVM垃圾回收器发现了它，就会将之回收

```
WeakReference<String> wrf = new WeakReference<String>(str);
```



软引用

软引用在程序内存不足时，会被回收

```java
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```



虚引用

虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中

```java
PhantomReference<String> prf = new PhantomReference<String>(new String("str"),
new ReferenceQueue<>());
```



## 深拷贝和浅拷贝的区别

浅拷贝 仅复制对象本身，而不复制对象内部的引用类型成员

深拷贝 不仅复制对象本身，还会递归地复制对象内部的引用类型成员



## final，finally和finalize区别

- **final**
  - `final`用于修饰类时，表示该类不能被继承
  - `final`用于修饰方法时，表示该方法不能被子类重写
  - `final`用于修饰变量时，表示该变量的值只能被赋值一次，即为常量
- **finaly**
  - `finally`是一个关键字，用于定义在try-catch语句中的代码块。无论异常是否被捕获，`finally`块中的代码都会被执行
- **finalize**
  - `inalize`是Object类中的一个方法，用于在对象被垃圾回收前执行清理操作



## Java 序列化中如果有些字段不想进行序列化

对于不想进行序列化的变量，使用 transient 关键字修饰。



##  IO 流

- 按照流的流向分，可以分为输入流和输出流； 
- 按照操作单元划分，可以划分为字节流和字符流；



- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。



## IO与 NIO的区别

是Java中用于处理输入和输出的API

IO：IO是基于流（Stream）的模型，它使用阻塞式I/O（Blocking I/O）来处理输入和输出

NIO：NIO是基于通道（Channel）和缓冲区（Buffer）的模型，它使用非阻塞式I/O来处理输入和输出



NIO相比于传统IO具有更好的性能和可扩展性，特别是在处理大量并发连接时。

传统IO适合于较少的连接数和简单的应用程序，而NIO适用于需要处理大量并发连接和高性能的网络应用程序





## 实现多线程有几种方法

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口（ JDK1.5>= ）
4. 线程池方式创建



### 实现Runnable、Callable接口的方式创建线程的优缺点

**Runnable**

- 优点：线程类只是实现了Runnable或者Callable接口，还可以继承其他类
- 缺点：编程稍微复杂一些，如果需要访问当前线程，则必须使用 Thread.currentThread() 方法

****

**Callable**

- 优点：：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this即可获取当前线程

- 缺点：：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了



## 如何停止一个正在运行的线程

1. 使用退出标志
2. 使用stop方法强行终止
3. 使用interrupt方法中断线程



## notify()和notifyAll()区别

**notify**：用于唤醒在当前对象上等待的单个线程；可能会导致死锁；

​	如果有多个线程在当前对象上调用了`wait()`方法进入等待状态，那么只有一个线程会被唤醒，但是哪一个线程被唤醒是不确定的。

**notifyAll**：用于唤醒在当前对象上等待的所有线程；不会导致死锁



## sleep()和wait()区别

**sleep**：属于Thread类；不会释放锁；时间到会⾃动恢复

**wait**：属于Object类；会释放当前线程持有的对象锁；需使⽤ notify()/notifyAll()直接唤醒





## Thread 类中的start() 和 run() 方法区别

start()方法被用来启动新创建的线程，执行内部调用了run()方法；



## 有三个线程T1,T2,T3,如何保证顺序执行

可以用线程类的join()方法在一个线程中启动另一 个线程另外一个线程完成该线程继续执行。

为了确保三个线程的顺序你应该先启动最后一个(T3调 用T2，T2调用T1)，这样T1就会先完成而T3最后完成

```java
Thread T1 = new Thread(() -> {
    // T1的任务
});

Thread T2 = new Thread(() -> {
    try {
        T1.join(); // 等待T1执行完成
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // T2的任务
});

Thread T3 = new Thread(() -> {
    try {
        T2.join(); // 等待T2执行完成
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // T3的任务
});

T1.start();
T2.start();
T3.start();

```



## Thread类中的yield方法有什么作用

法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行



## 线程池中submit() 和 execute()方法有什么区别

**execute**： 定义在Executor接口中，execute()方法的返回类型是void

**submit**： 定义在ExecutorService接口中，返回持有计算结果的Future对象



## 对线程池的理解

1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性；如果无限制的创建，不仅会消耗系统资源，还会降 低系统的稳定性



## 常用的线程池

- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按 照任务的提交顺序执行。 
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线 程达到线程池的最大大小。
-  newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线 程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 
- newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行 任务的需求。 
- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任 务的需求



## 产生死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用 
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放 
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系



## 如何避免死锁

指定获取锁的顺序

比如只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可 以避免死锁！



## 线程安全需要保证几个基本特征

- 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。 
- 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将 线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
- 有序性，是保证线程内串行语义，避免指令重排等



## ThreadLocal原理

**内部实现**

- 对象内部都包含了一个ThreadLocalMap对象
- ThreadLocalMap是一个自定义的散列表，它的键是ThreadLocal对象，值是对应线程的变量副本
- ThreadLocal的`get()`；获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后从Map中根据ThreadLocal对象获取变量副本
- ThreadLocal的`set()`方法；先获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后将ThreadLocal对象和变量副本存入Map中
- ThreadLocal的`remove()`方法；获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后从Map中移除对应的键值对。



**线程间隔离**

- 每个线程都拥有自己的ThreadLocalMap对象，不同线程之间的变量副本相互独立，互不影响
- 创建ThreadLocal对象并设置变量值时，只有当前线程可以访问该变量，其他线程无法访问
- 即使是相同的ThreadLocal对象，不同线程之间的变量副本也是独立的





# spring

## 什么是spring

Spring 是一个轻量级的IoC和AOP容器框架。用于简化企业应用程序的开发

有以下优点：

- 轻量：Spring 是轻量的，基本的版本大约2MB。
- 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找 依赖的对象们
-  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
- 容器：Spring 包含并管理应用中对象的生命周期和配置。
- MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
- 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务
- 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛 出的）转化为一致的unchecked 异常



有以下核心模块：

- Spring Core：核心类库，提供IOC服务；
- Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；
- Spring AOP：AOP服务； Spring DAO：对JDBC的抽象，简化了数据访问异常的处理
- Spring ORM：对现有的ORM框架的支持
- Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；
- Spring MVC：提供面向Web应用的Model-View-Controller实现。



##  Autowired和Resource关键字的区别

@Resource和@Autowired都是做bean的注入时使用

@Resource并不是Spring的注解，是java的原生注解；按照ByName自动注入

@Autowired为Spring提供的注解；按照类型（byType）装配依赖对象



## 依赖注入的几种方式

1. 构造器注入
2. setter注入
3. 接口注入





## 对Spring MVC的理解

是spring在原 有基础上，又提供了web应用的MVC模块

可以简单的把springMVC理解为是spring的一个模块



MVC模式

MVC：MVC是一种设计模式

- M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）
- V-View 视图（做界面的展示 jsp，html……）
- C-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）

![image-20240527234219674](C:\Users\f\Documents\面试题\assets\image-20240527234219674.png)

```
1、 用户发送请求至前端控制器DispatcherServlet。
2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器
拦截器(如果有则生成)一并返回给DispatcherServlet。
4、 DispatcherServlet调用HandlerAdapter处理器适配器。
5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6、 Controller执行完成返回ModelAndView。
7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9、 ViewReslover解析后返回具体View。
10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11、 DispatcherServlet响应用户。
```



## SpringMVC常用的注解

- @RequestMapping
- @RequestBody
- @ResponseBody



## 对Spring的AOP理解

AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所 共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复 代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。



Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK 动态代理去创建代理对象

而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib 动态代理生成一个被代理对象的子类来作为代理





## 对Spring的IOC理解

IOC就是控制反转，是指创建对象的控制权的转移。

最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反 射机制

Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。



## spring bean的生命周期

实例化

初始init

接收请求service

销毁destroy



## Spring支持的几种bean的作用域

- singleton：默认单例
- prototype：为每一个bean请求提供一个实例
- request：为每一个网络请求创建一个实例；在请求完成以后，bean会失效并被垃圾回收器回收
- session：与request范围类似，确保每个session中有一个bean的实例，在session过期后， bean会随之失效。
- global-session：全局作用域



## Spring框架中都用到了哪些设计模式

- 简单工厂模式
  - Spring 中的 BeanFactory 就是简单工厂模式的体现
- 工厂模式
  - Spring 中的 FactoryBean 就是典型的工厂方法模式
- 单例模式
  - 在 spring 中（作用域）用到的单例模式有： scope="singleton" ，注册式单例模式，bean 存放于 Map 中。bean name 当做 key，bean 当做 value。
- 原型模式
  - 在 spring 中用到的原型模式有： scope="prototype" ，每次获取的是通过克隆生成的新实例
- 代理模式
  - Spring 中经典的 AOP，就是使用动态代理实现的，分 JDK 和 CGlib 动态代理
- 适配器模式
  - Spring 中的 AOP 中 AdvisorAdapter 类
- 观察者模式
  - Spring 中的 Event 和 Listener
    - ApplicationEvent，该抽象类继承了 EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。
    - ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承 EventListener
- 模板模式
  - JdbcTemplate 就是非常经典的模板模式 的应用，里面的 execute 方法，把整个算法步骤都定义好了
- 责任链模式
  - DispatcherServlet 中的 doDispatch() 方法中获取与请求匹配的处理器 HandlerExecutionChain，this.getHandler() 方法的处理使用到了责任链模式



## Spring 中 ApplicationContext 和 BeanFactory 的区别

