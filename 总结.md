# 基础

## 面向对象和面向过程的区别

面向过程：用函数一步一步的实现需求，需要的时候进行调用

面向对象：把问题分为多个对象，建立对象也是为了描述事物解决问题的过程发生的行为；面向对象有**封装、集成、多态**的特性；易维护、复用、扩展



## 线程、程序、进程的基本概念。以及他们之间关系

简单的来说，程序是静态的代码集合，进程是程序的执行实例，而线程是进程内部的执行单元

关系是程序被加载到内存中执行后，会创建一个进程，进程内部可以包含一个或多个线程，线程共享进程的资源



## 重写和重载区别

重写：

1. 子类集成父类或实现接口（对方法的重写）
2. 方法名、参数列表、返回类型 必须相同
3. 子类方法修饰符 > 被重写的方法修饰符
4. 不能抛出新的异常

重载

同类中，同名的方法不同参数；类型不同，个数不同；对返回类型无要求



## == 和 equal

== 变量在“栈”里面，对象在“堆”里面；两端比较的是内存中的地址

equals 比较的是两个对象的内容是否相等；一般将常量写在左侧



## Java创建对象有几种方式

1. new创建新对象
2. 通过反射机制
3. 采用clone机制
4. 通过序列化机制



## String、StringBuffer 和 StringBuilder区别

String 是只读字符串，是一个对象，被final修饰的字符数组，被引用的字符串不能被改变，因此每次对String的操作都会生成新的String对象

StringBuffer 和 StringBuilder都继承于了AbstractStringBuilder抽象类

底层都是可变的字符数组，对字符串频繁操作建议用StringBuffer 和 StringBuilder

StringBuffer 加了同步锁，因此线程安全；而StringBuilder则没有对此操作，因此线程不安全，但效率相当于StringBuffer 高



## 有数组了为什么还要搞个 ArrayList

在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了

而 ArrayList 可以使用默认的大小，当元素个数到达一定程度 后，会自动扩容



## ArrayList和linkedList的区别

ArrayList 基于数组实现，数组则是基于索引数据结构，因此搜索和读取比较快；删除开销大，因为需要对数组中所有数据进行重排

linkedList 是一个双向链表，在添加和删除更优，查询弱于ArrayList （基本是指数据量大时）



父类不同

1. arraylist <--- abstractLIst < --- collection
2. linkedList <--- abstractSquentialList < ---abstractList <--- collection



## List,Set,Map三者的区别

- List：
  - 是一个有序集合，可以包含重复元素
  - 按照插入顺序访问元素，并且可以通过索引进行随机访问
  - 通过索引查找快，增删速度慢
- Set：
  - 不允许包含重复元素的集合
  - 保证元素的顺序
  - 检索元素效率低下，删除和插入效率高
- Map：
  - 是一个键值对的集合，每个键都唯一
  - 键是不可重复的，但值可以重复
  - 不保证键值对的顺序



## HashMap和HashTable的区别

1. 父类不同
   1. HashMap是继承自AbstractMap类
   2. 而Hashtable是继承自Dictionary类。
2. 对null的支持不同
   1. Hashtable：key和value都不能为null
   2. HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个 key值对应的value为null。
3. 安全性不同
   1. HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题
   2. Hashtable是线程安全的，它的每个方法上都有synchronized 关键字
   3. ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为 ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。
4. 初始容量大小和每次扩充容量大小不同
   1. HashMap初始容量为16，当容量为16*0.75时，每次扩容是原容量的两倍
   2. HashTable初始容量为11，当容量为11*0.75时，每次扩容是原容量的两倍+1
5. 计算hash值的方法不同
   1. HashMap和HashTable都是通过调用键对象的`hashCode()`方法来计算哈希码，但是HashTable还会进行额外的处理以确保哈希码为正数



## HashMap 的长度为什么是 2 的 N 次方呢

为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞

也就是说尽量把数 据能均匀的分配，每个链表或者红黑树长度尽量相等

```
取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说
hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进
制位操作 & ，相对于 % 能够提高运算效率
```



## HashMap 与 ConcurrentHashMap 的异同

1. 都是 key-value 形式的存储
2.  HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的
3.  HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑 树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红 黑树查询速度快
4. HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩 容；
5. ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry
   1. Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized 来保证并发安全进行实现



## SynchronizedMap和ConcurrentHashMap有什么区别

**SynchronizedMap**：通过Collections工具类提供的静态方法`Collections.synchronizedMap()`来创建的，通过在每个方法上添加`synchronized`关键字来实现同步

**ConcurrentHashMap**： 使用分段锁（Segment），将整个Map分成多个Segment，每个Segment拥有自己的锁，不同Segment的数据可以并发读写





## 红黑树有哪几个特征

- 每个节点是 黑色或红色
- 根节点是黑色
- 每个叶子节点都是黑色(指向空的叶子节点)
- 如果一个叶子节点是红色，那么其子节点必须都是黑色的
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点



##  Java的四种引用，强弱软虚

强引用

平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收

```java
String str = new String("str");
System.out.println(str);
```



弱引用

弱引用就是只要JVM垃圾回收器发现了它，就会将之回收

```
WeakReference<String> wrf = new WeakReference<String>(str);
```



软引用

软引用在程序内存不足时，会被回收

```java
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```



虚引用

虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中

```java
PhantomReference<String> prf = new PhantomReference<String>(new String("str"),
new ReferenceQueue<>());
```



## 深拷贝和浅拷贝的区别

浅拷贝 仅复制对象本身，而不复制对象内部的引用类型成员

深拷贝 不仅复制对象本身，还会递归地复制对象内部的引用类型成员



## final，finally和finalize区别

- **final**
  - `final`用于修饰类时，表示该类不能被继承
  - `final`用于修饰方法时，表示该方法不能被子类重写
  - `final`用于修饰变量时，表示该变量的值只能被赋值一次，即为常量
- **finaly**
  - `finally`是一个关键字，用于定义在try-catch语句中的代码块。无论异常是否被捕获，`finally`块中的代码都会被执行
- **finalize**
  - `inalize`是Object类中的一个方法，用于在对象被垃圾回收前执行清理操作



## Java 序列化中如果有些字段不想进行序列化

对于不想进行序列化的变量，使用 transient 关键字修饰。



##  IO 流

- 按照流的流向分，可以分为输入流和输出流； 
- 按照操作单元划分，可以划分为字节流和字符流；



- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。



## IO与 NIO的区别

是Java中用于处理输入和输出的API

IO：IO是基于流（Stream）的模型，它使用阻塞式I/O（Blocking I/O）来处理输入和输出

NIO：NIO是基于通道（Channel）和缓冲区（Buffer）的模型，它使用非阻塞式I/O来处理输入和输出



NIO相比于传统IO具有更好的性能和可扩展性，特别是在处理大量并发连接时。

传统IO适合于较少的连接数和简单的应用程序，而NIO适用于需要处理大量并发连接和高性能的网络应用程序





## 实现多线程有几种方法

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口（ JDK1.5>= ）
4. 线程池方式创建



### 实现Runnable、Callable接口的方式创建线程的优缺点

**Runnable**

- 优点：线程类只是实现了Runnable或者Callable接口，还可以继承其他类
- 缺点：编程稍微复杂一些，如果需要访问当前线程，则必须使用 Thread.currentThread() 方法

****

**Callable**

- 优点：：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this即可获取当前线程

- 缺点：：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了



## 如何停止一个正在运行的线程

1. 使用退出标志
2. 使用stop方法强行终止
3. 使用interrupt方法中断线程



## notify()和notifyAll()区别

**notify**：用于唤醒在当前对象上等待的单个线程；可能会导致死锁；

​	如果有多个线程在当前对象上调用了`wait()`方法进入等待状态，那么只有一个线程会被唤醒，但是哪一个线程被唤醒是不确定的。

**notifyAll**：用于唤醒在当前对象上等待的所有线程；不会导致死锁



## sleep()和wait()区别

**sleep**：属于Thread类；不会释放锁；时间到会⾃动恢复

**wait**：属于Object类；会释放当前线程持有的对象锁；需使⽤ notify()/notifyAll()直接唤醒





## Thread 类中的start() 和 run() 方法区别

start()方法被用来启动新创建的线程，执行内部调用了run()方法；



## 有三个线程T1,T2,T3,如何保证顺序执行

可以用线程类的join()方法在一个线程中启动另一 个线程另外一个线程完成该线程继续执行。

为了确保三个线程的顺序你应该先启动最后一个(T3调 用T2，T2调用T1)，这样T1就会先完成而T3最后完成

```java
Thread T1 = new Thread(() -> {
    // T1的任务
});

Thread T2 = new Thread(() -> {
    try {
        T1.join(); // 等待T1执行完成
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // T2的任务
});

Thread T3 = new Thread(() -> {
    try {
        T2.join(); // 等待T2执行完成
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // T3的任务
});

T1.start();
T2.start();
T3.start();

```



## Thread类中的yield方法有什么作用

法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行



## 线程池中submit() 和 execute()方法有什么区别

**execute**： 定义在Executor接口中，execute()方法的返回类型是void

**submit**： 定义在ExecutorService接口中，返回持有计算结果的Future对象



## 对线程池的理解

1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性；如果无限制的创建，不仅会消耗系统资源，还会降 低系统的稳定性



## 常用的线程池

- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按 照任务的提交顺序执行。 
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线 程达到线程池的最大大小。
-  newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线 程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 
- newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行 任务的需求。 
- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任 务的需求



## 产生死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用 
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放 
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系



## 如何避免死锁

指定获取锁的顺序

比如只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可 以避免死锁！



## 线程安全需要保证几个基本特征

- 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。 
- 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将 线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
- 有序性，是保证线程内串行语义，避免指令重排等



## ThreadLocal原理

**内部实现**

- 对象内部都包含了一个ThreadLocalMap对象
- ThreadLocalMap是一个自定义的散列表，它的键是ThreadLocal对象，值是对应线程的变量副本
- ThreadLocal的`get()`；获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后从Map中根据ThreadLocal对象获取变量副本
- ThreadLocal的`set()`方法；先获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后将ThreadLocal对象和变量副本存入Map中
- ThreadLocal的`remove()`方法；获取当前线程，并通过当前线程获取对应的ThreadLocalMap对象，然后从Map中移除对应的键值对。



**线程间隔离**

- 每个线程都拥有自己的ThreadLocalMap对象，不同线程之间的变量副本相互独立，互不影响
- 创建ThreadLocal对象并设置变量值时，只有当前线程可以访问该变量，其他线程无法访问
- 即使是相同的ThreadLocal对象，不同线程之间的变量副本也是独立的





# spring

## 什么是spring

Spring 是一个轻量级的IoC和AOP容器框架。用于简化企业应用程序的开发

有以下优点：

- 轻量：Spring 是轻量的，基本的版本大约2MB。
- 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找 依赖的对象们
-  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
- 容器：Spring 包含并管理应用中对象的生命周期和配置。
- MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
- 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务
- 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛 出的）转化为一致的unchecked 异常



有以下核心模块：

- Spring Core：核心类库，提供IOC服务；
- Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；
- Spring AOP：AOP服务； Spring DAO：对JDBC的抽象，简化了数据访问异常的处理
- Spring ORM：对现有的ORM框架的支持
- Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；
- Spring MVC：提供面向Web应用的Model-View-Controller实现。



##  Autowired和Resource关键字的区别

@Resource和@Autowired都是做bean的注入时使用

@Resource并不是Spring的注解，是java的原生注解；按照ByName自动注入

@Autowired为Spring提供的注解；按照类型（byType）装配依赖对象



## 依赖注入的几种方式

1. 构造器注入
2. setter注入
3. 接口注入





## 对Spring MVC的理解

是spring在原 有基础上，又提供了web应用的MVC模块

可以简单的把springMVC理解为是spring的一个模块



MVC模式

MVC：MVC是一种设计模式

- M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）
- V-View 视图（做界面的展示 jsp，html……）
- C-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）

![image-20240527234219674](C:\Users\f\Documents\面试题\assets\image-20240527234219674.png)

```
1、 用户发送请求至前端控制器DispatcherServlet。
2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器
拦截器(如果有则生成)一并返回给DispatcherServlet。
4、 DispatcherServlet调用HandlerAdapter处理器适配器。
5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6、 Controller执行完成返回ModelAndView。
7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9、 ViewReslover解析后返回具体View。
10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11、 DispatcherServlet响应用户。
```



## SpringMVC常用的注解

- @RequestMapping
- @RequestBody
- @ResponseBody



## 对Spring的AOP理解

AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所 共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复 代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。



Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK 动态代理去创建代理对象

而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib 动态代理生成一个被代理对象的子类来作为代理





## 对Spring的IOC理解

IOC就是控制反转，是指创建对象的控制权的转移。

最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反 射机制

Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。



## spring bean的生命周期

实例化

初始init

接收请求service

销毁destroy



## Spring支持的几种bean的作用域

- singleton：默认单例
- prototype：为每一个bean请求提供一个实例
- request：为每一个网络请求创建一个实例；在请求完成以后，bean会失效并被垃圾回收器回收
- session：与request范围类似，确保每个session中有一个bean的实例，在session过期后， bean会随之失效。
- global-session：全局作用域



## Spring框架中都用到了哪些设计模式

- 简单工厂模式
  - Spring 中的 BeanFactory 就是简单工厂模式的体现
- 工厂模式
  - Spring 中的 FactoryBean 就是典型的工厂方法模式
- 单例模式
  - 在 spring 中（作用域）用到的单例模式有： scope="singleton" ，注册式单例模式，bean 存放于 Map 中。bean name 当做 key，bean 当做 value。
- 原型模式
  - 在 spring 中用到的原型模式有： scope="prototype" ，每次获取的是通过克隆生成的新实例
- 代理模式
  - Spring 中经典的 AOP，就是使用动态代理实现的，分 JDK 和 CGlib 动态代理
- 适配器模式
  - Spring 中的 AOP 中 AdvisorAdapter 类
- 观察者模式
  - Spring 中的 Event 和 Listener
    - ApplicationEvent，该抽象类继承了 EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。
    - ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承 EventListener
- 模板模式
  - JdbcTemplate 就是非常经典的模板模式 的应用，里面的 execute 方法，把整个算法步骤都定义好了
- 责任链模式
  - DispatcherServlet 中的 doDispatch() 方法中获取与请求匹配的处理器 HandlerExecutionChain，this.getHandler() 方法的处理使用到了责任链模式



## Spring 中 ApplicationContext 和 BeanFactory 的区别

- 所属包不同
  - BeanFactory在spring-beans.jar
  - ApplicationContext在spring-context.jar
- 国际化
  - BeanFactory 不支持国际化，没有实现MessageResource
  - ApplicationContext 却可以
- 事件机制
  - ApplicationContext事件机制是观察者设计模式的 实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。 如果容器中有一个ApplicationListener Bean，每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发
- 底层资源的访问
  - ApplicationContext 扩展了 ResourceLoader（资源加载器）接口，从而可以用来加载多个 Resource
  - BeanFactory 是没有扩展 ResourceLoader
- 创建方式
  - BeanFactory 通常以编程的方式被创建
  - ApplicationContext 能以声明的方式创建，也可以使用编程的方式
    - 编程式：通过代码new的方式
    - 声明式：通过配置文件或注解的方式
- 延迟加载
  - BeanFactroy 采用的是延迟加载形式来注入 Bean ；只有在使用时才会具体实例化bean
  - ApplicationContext 是容器启动时就创建所有bean



## Spring 框架中的单例 Bean 是线程安全的么

spring 中的 bean 默认是[单例](https://so.csdn.net/so/search?q=单例模式&spm=1001.2101.3001.7020)的；框架并没有对单例 bean 进行多线程的封装处理

某种程度上来说 bean 也是安全的；但如果 Bean 内部存在可变状态，开发者需要自行确保线程安全性



## Spring 是怎么解决循环依赖的

A依赖B；B依赖A

自我依赖

A依赖B；B依赖C；C依赖A；

使用三级缓存，就用用来存放不同类型的bean

一级缓存，存放的是完全初始化好的bean，可以直接使用

二级缓存，存放的原始bean，其里面的属性还没被赋值

三级缓存，存放的是bean工厂对象，生成原始bean对象，并放入二级缓存



主要是把bean的实例化，bean的属性注入分离出来



![image-20240529225649169](C:\Users\f\Documents\面试题\assets\image-20240529225649169.png)



- 多实例的Setter注入导致的循环依赖，需要把Bean改成单例。
- 构造器注入导致的循环依赖，可以通过@Lazy注解
- DependsOn注解： 使用@DependsOn注解指定依赖项的加载顺序，以避免出现循环依赖问题
- 重新设计





## 解决依赖冲突的方法

- 情况一：项目依赖了同一Jar包的多个版本，并且选错了版本；
- 情况二：同样的类在不同的Jar包中出现，导致JVM加载了错误的类；



- Maven：在命令行中执行mvn dependency:tree，查看项目的依赖树，找出冲突的依赖；在pom.xml中使用标签来排除冲突的依赖版本。
- 设置 classpath 指定jar包加载的先后顺序



## 事务三要素

- 数据源：表示具体的事务性资源，是事务的真正处理者，如MySQL等。
- 事务管理器：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。
- 事务应用和属性配置：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属 性如隔离级别、超时时间等。



## 事务的隔离级别

- 未提交读(Read Uncommitted)：可读取到事务未提交的数据，隔离性差，会出现脏读，不可重复读，幻读问题
  - 脏读：在一个事务中，修改数据还没提交，就被另一个事务读取到了；产生错误是数据
  - 不可重复读：在一个事务中，两次读取同一数据却得到了不同的结果；可能是因为在两次读取之间另一个事务修改了数据并且提交了
  - 幻读：在一个事务中，两次查询同一个范围的数据，但是得到了不同数量的行。这是因为在两次查询过程中有另外一个事务插入数据造成的。
    - 不可重复读是在同一个数据行上发生的，而幻读是在一个数据范围上发生的
    - 不可重复读是由于并发事务中的数据更新导致的，而幻读则是由于并发事务中的数据插入导致的
- 已提交读(Read Committed)：可读取到事务已提交的数据，隔离性一般，不会出现脏读问题，但是会出现不可重复读，幻读问题
- 可重复读(Repeated Read)：可防止脏读（当前内存读），防止不可重复读问题，防止会出现的幻读问题，但是并发能力较差
- 可串行化(Serializable)：隔离性比较高，可以实现串行化读取数据，但是事务的并发度就没有了；这是事务的最高级别，在每条读的数据上，加上锁，使之不可能相互冲突





## 事务的传播级别

**Spring事务定义了7种传播机制**



- PROPAGATION_REQUIRED:默认的Spring事物传播级别，若当前存在事务，则加入该事务，若 不存在事务，则新建一个事务。
- PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建 一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交
- PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务， 则新建一个事务
- PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行
- PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂 起
- PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常
- PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。



##  Spring框架的事务管理优点

为不同的的事务API提供了统一的编程模型。



# Springboot

优点：

- 独立运行：内嵌了各种容器，如：servlet，tomcat，jetty等
- 简化配置：starter-web启动器自动依赖很多组件，简化了配置
- 自动配置：根据当前类路径的类，jar包自动配置bean
- 应用监控：提供监控服务，做健康检测

## Spring Boot 的核心注解

启动类上的注解：**@SpringBootApplication**，由以下三个注解组成

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能

@EnableAutoConfiguration：打开自动配置的功能

@ComponentScan：组件扫描



## 运行Spring Boot方式

- 使用命令打包运行
- Maven/Gradle 插件运行
- 编译器启动主类



## 什么是Spring Boot 中的 Starters

Starters可以理解为启动器；包含了一系列的依赖包，比如需要jpa，只需要加入 spring-boot-starter-data-jpa 启动器依赖即可



## Spring Boot中的监视器

actuator是spring启动框架中的重要功能之一；可在生产环境中查看正在运行的应用程序状态；



## 如何使用Spring Boot实现异常处理

Spring提供了一种使用ControllerAdvice处理异常的方法；可以实现此类来处理控制器类抛出的异常



## springboot常用的starter

- spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持
- spring-boot-starter-data-jpa 数据库支持
- spring-boot-starter-data-redis redis数据库支持



##  Spring Boot 配置加载顺序

1. `bootstrap.yml`
2. `bootstrap.properties`
3. `application.yaml`
4. `application.properties`
5. `系统环境变量`
6. `命令行参数`



## Spring Boot 的核心配置文件

- application
  - 主要用于 Spring Boot 项目的自动化配置
- bootstrap
  - 一般用于 Spring Cloud配置中心，需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息
  - 固定的不能被覆盖的属性







---

# MyBatis

## 什么是MyBatis

Mybatis是一个半ORM框架，内部封装了JDBC，开发时只需要关注SQL 语句本身；不用花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，直接编写原生sql就是

可以用过xml或注解映射信息，将 POJO映射成数据库中的记录，避免手动设置参数或获取结果集



## MyBatis的优点和缺点

- 优点

  - 基于SQL语句编程，相当灵活，便于统一管理，支持动态sql

  - 相对比原生jdbc，代码量减少了很多；不需要手动开关连接
  - 支持映射标签，支持对象关系组件维护

- 缺点

  - sql工作量较大，特别是字段多的时候



## \#{}和${}的区别

\#{}是预编译处理；${}是字符串替换

- Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；
- Mybatis在处理${}时，就是把${}替换成变量的值。
- 使用#{}可以有效的防止SQL注入，提高系统安全性。



## 当实体类中的属性名和表中的字段名不一样 

1. 在sql中定义别名
2. 使用property定义属性名，column定义列名



## Mybatis是如何进行分页的？分页插件的原理是什么

Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页

基本原理是使用Mybatis提供的插件接口；实现自定义插件，在插件的拦截方法内拦截 待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数



## Mybatis是否支持延迟加载？如果支持，它的实现原理是什么

仅支持association关联对象和collection关联集合对象的延迟加载

- association指的就是一 对一
- collection指的就是一对多查询
- 可以配置是否启用延迟加载 lazyLoadingEnabled=true|false



原理

> 使用CGLIB创建目标对象的代理对象，调用方法时，进入拦截器方法；比如a.getB().getName()
>
> 拦截器invoke发现getB()是null，就会单独发送先保存好的管理B对象的sql，把B查询出，如何调用set赋值进去
>
> 接着完成a.getB().getName()调用



> 使用CGLIB创建目标对象的代理对象，当访问代理对象的方法时，代理逻辑会检查对应的数据是否已经加载。如果还没有加载，代理对象会执行实际的查询操作来加载数据
>
> 在执行业务代码时，当第一次访问代理对象的某个属性或方法时，MyBatis 会触发懒加载，执行必要的SQL查询并填充代理对象的数据
>
> 一旦触发懒加载，MyBatis 将调用相应的 Mapper 接口和 SQL 映射，执行数据库查询并获取数据。获取的数据随后填充到代理对象中，替换原来的懒加载占位



## Mybatis的缓存机制

### 一级缓存

> 在运行过程中，可能在一次数据库会话中，执行多次查询条件完全相同的 SQL；如果是相同的 SQL 语句，会优先命中一级缓存， 避免直接对数据库进行查询，提高性能
>
> 一级缓存的生命周期和 SqlSession 一致
>
> 一级缓存内部设计简单，只是一个没有容量限定的 HashMap



#### 什么时候一级缓存失效

> sqlSession的clearCache()方法，手动清空缓存
>
> 执行了INSERT或DELETE或UPDATE语句。不管你是操作哪张表的，都会清空一级缓存



### 二级缓存

**前置条件**

> 开启二级缓存：cacheEnabled为true；开启后CachingExecutor会修饰Executor；进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询
>
> 对应xml中添加<cache/>标签；对应的mapper标签中想要设置namespace
>
> ⼆级缓存的实体类对象**必须是可序列化**；也就是必须实现Serializable
>
> **SqlSession对象关闭或提交**之后，⼀级缓存中的数据才会被写⼊到⼆级缓存当中。此时⼆级缓存才可⽤



> 从一级缓存中看，的共享范围就是一个 SqlSession 内部，如果多个 SqlSession 之间需要共享缓存，则需要使用到二级缓存
>
> 二级缓存是 `namespace` 级别的缓存。一级缓存是默认开启的，而二级缓存需要手动开启
>
> 查询语句执行时，MyBatis 会首先尝试从二级缓存中查找对应的数据
>
> 缓存中存在数据，则直接返回缓存中的数据
>
> 如果缓存中不存在数据，则执行数据库查询，并将查询结果存入缓存
>
> 如果其他 SqlSession 对同样的查询进行了修改，那么会触发缓存的失效，使得下次查询会重新从数据库中获取数据



![image-20240530012926071](C:\Users\f\Documents\面试题\assets\image-20240530012926071.png)



**二级缓存失效**

只要两次查询之间出现了增删改操作。⼆级缓存就会失效。【⼀级缓存也会失效】



## MyBatis 中比如 UserMapper.java 是接口，为什么没有实现类还能调用

使用JDK动态代理+MapperProxy。本质上调用的是MapperProxy的invoke方法





# Mysql

## 数据库三大范式

- 第一范式：列不可再分
- 第二范式：非主键列要完全依赖于主键（主要是说在联合主键的情况下，非主键列不能只依赖于主键的一部分）
  - 比如“学生ID”和“课程ID”组成的联合主键；分数完全依赖于联合主建，而“课程名称”只依赖于“课程ID”，则不符合2NF

![image-20240530223343983](C:\Users\f\Documents\面试题\assets\image-20240530223343983.png)

- 非主键字段只依赖于主键，而不依赖于其他非主键字段

  ![image-20240530225151838](C:\Users\f\Documents\面试题\assets\image-20240530225151838.png)



## MySQL数据库引擎

- MYISAM
  - 曾经的默认引擎，不支持事务和行级锁；但性能高；适合读或读多写少的情况；并发性能差，占用空间 相对较小
- Innodb
  - 5.5开始默认引擎，支持事务和行级锁，自增长，外键约束和崩溃恢复功能；并发能力强，占用空间是MYISAM的2.5倍
  - 相比于myisam处理效率慢些
- Memory
  - 全表锁，将数据存储在内存中，读写速度非常快；但不支持事务和崩溃恢复；重启或崩溃会丢失数据
- MERGE
  - 是一组MYISAM表的组合；多个 MyISAM 表合并成的一个表



## 说InnoDB与MyISAM的区别

1.  InnoDB支持事务，MyISAM不支持
2. InnoDB支持外键，而MyISAM不支持
3. InnoDB不保存表的具体行数，而MyISAM用 一个变量保存了整个表的行数
4. Innodb不支持全文索引，而MyISAM支持全文索引
5. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键；而MyISAM是非聚集索引，数据文件是分离的， 索引保存的是数据文件的指针。主键索引和辅助索引是独立



## 数据库的事务

**多条sql语句，要么全部成功，要么全部失败**

### 事务的特性

- 原子性：所有操作都成功， 整个事务才会提交；否则撤销
- 一致性：操作的数值的总数是不变的；如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的
- 隔离性：在并发数据操作时，不同的事务拥有各自的数据空间；不会彼此干扰
- 持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。



## 索引

索引是帮助MySQL**高效获取数据的数据结构**；通俗的说，数据库索引好比是一本书 前面的目录，**能加快数据库的查询速度**

索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中 的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）



## 主键与索引有什么区别

- **主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键**
- 主键不允许为空值，唯一索引列允许空值；
- 一个表只能有一个主键，但是可以有多个唯一索引；
- **主键可以被其他表引用为外键，唯一索引列不可以**
-  主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构



## SQL优化手段

- 尽可能避免select *
- 减少使用子查询，使用关联查询替代
- 减少in或者not in；使用exists或not exists替代
- 尽量在where后避免使用 不等于，否则索引会失效
- 判断null使用is null或者is not null代替



## drop、delete与truncate的区别

drop、delete、truncate都表示删除

速度：drop> truncate >delete 

- delete和truncate只删除表的数据不删除表的结构
-  delete 语句是dml,这个操作会放到rollback segement中,事务提交之后才生效
- truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚

> `DELETE` 命令用于删除指定的数据
>
> `TRUNCATE` 命令用于删除整个表的数据
>
> 如果需要删除整个表或数据库，使用 `DROP` 命令



## 什么是视图

是一种虚拟的表，具有和物理表相同的功能；试图通常是 有一个表或者多个表的行或列的子集

对视图进行增，改，查，操作；对视图的修改不影响基本表

> 如果视图是基于简单查询，增删改操作将直接影响底层表；如果视图包含聚合函数、子查询或 join 操作，增删改操作将不影响底层表
>
> 如果视图是基于简单查询，修改原表将直接影响视图；如果视图是基于聚合函数或子查询，修改原表将不直接影响视图；如果视图是基于 Join 操作，修改原表将影响视图。





## 内联接、左外联接、右外联接

- 内联接（Inner Join）：匹配2张表中相关联的记录
- 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记 录，右表中未匹配到的字段用NULL表示
- 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记 录，左表中未匹配到的字段用NULL表示



## 大表如何优化

1. 限制数据范围条件的查询语句
2. 读/写分离
3. 垂直分区
   1. 根据数据库里面数据表的相关性进行拆分；简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表
   2. 垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外， 垂直分区可以简化表的结构，易于维护
   3. 垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层 进行Join来解决。此外，垂直分区会让事务变得更加复杂
4. 水平分区
   1. 保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达 到了分布式的目的。 水平拆分可以支撑非常大的数据量
   2. 优点：支持非常大的数据量存储，应用端改造也少
   3. 缺点：提高了逻辑、部署、运维的各种复杂度



## 分库分表之后,id 主键如何处理

- UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低
- 数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用
- redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。
- 雪花算法：
- Leaf分布式ID生成系统 ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋 势递增、单调递增、信息安全



## SQL **是如何执行的**

```sql
select name from t_user where id=1
```

1. 取得链接，使用使用到 MySQL 中的连接器
2. 查询缓存，key 为 SQL 语句，value 为查询结果，如果查到就直接返回。不建议使用次缓存， 在 MySQL 8.0 版本已经将查询缓存删除
3. 分析器，分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。所以一般语法错 误在此阶段
4. 优化器，是在表里有多个索引的时候，决定使用哪个索引；或者一个语句中存在多表关联的时 候（join），决定各个表的连接顺序
5. 执行器，通过分析器让 SQL 知道你要干啥，通过优化器知道该怎么做，于是开始执行语句
   1. 判断是否具备此权限
   2. 根据表的引擎定义，去使用这个引擎提供的接口，获取这个表的第一行
   3. 判断 id 是都 等于 1。如果是，直接返回；如果不是继续调用引擎接口去下一行，重复相同的判断，直到取 到这个表的最后一行，最后返回。



## 索引有什么优缺点

- 优点
  - 加快数据检索速度，提高对数据访问效率
  - 提高数据查询性能
- 缺点
  - 占用大量硬盘空间
  - 数据的增删改等更新操作，需要维护索引时间，降低更新速度



## varchar 与 char 的区别？varchar(30) 中的 30 代表的涵义

- varchar 与 char 的区别，char 是一种固定长度的类型，varchar 则是一种可变长度的类型
- varchar(30) 中 30 的涵义最多存放 30 个字符。varchar(30) 和 (130) 存储 hello 所占空间一 样，但后者在排序时会消耗更多内存
- 对效率要求高用 char，对空间使用要求高用 varchar。



##  int(11) 中的 11 代表什么涵义

int(11) 中的 11，不影响字段存储的范围，只影响展示效果；会在前面补0达到此长度



## 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢

InnoDB 是去实时统计结果，会全表扫描

MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可



## MySQL 索引类型有哪些

- 主键索引
  - 索引列中的值必须是唯一的，不允许有空值。
- 普通索引
  - 基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
- 唯一索引
  - 索引列中的值必须是唯一的，但是允许为空值。
- 全文索引
  - 只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。
  - 字段长度比较大时；普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引
- 空间索引
- 前缀索引
  - 在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不 能指定
- 组合索引
  - 组合索引的使用，需要遵循**最左前缀匹配原则（最左匹配原则）**。一般情况下在条件允许的情 况下使用组合索引替代多个单列索引使用



## 什么时候不要使用索引

- 经常增删改的列不要建立索引
- 有大量重复的列不建立索引
- 表记录太少不要建立索引。



## 什么是 MVCC

多版本并发控制（MVCC=Multi-Version Concurrency Control），是一种用来解决读 - 写冲突的无 锁并发控制

也就是为事务分配单向增长的时间戳，为每个修改保存一个版本

版本与事务时间戳 关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）

这样在读操作不用阻塞写操 作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读



## MVCC 可以为数据库解决什么问题

在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数 据库并发读写的性能

同时还可以解决脏读、幻读、不可重复读等事务隔离问题



## MVCC 的实现原理

MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突

它的实现原理主 要是依赖记录中的 3 个隐式字段、undo 日志、Read View 来实现的



## MySQL 数据库的锁

1. 共享锁
   1. 不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响
2. 排他锁
   1. 一个写操作阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用 户读取正在写入的资源。
3. 表锁
   1. 系统开销最小，会锁定整张表，MyISAM 使用表锁。
4. 行锁
   1. 容易出现死锁，发生冲突概率低，并发高，InnoDB 支持行锁（必须有索引才能实现， 否则会自动锁全表，那么就不是行锁了）



## 悲观锁和乐观锁

- 悲观锁
  - 悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据
  - 当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定
  - 共享锁【shared locks】又称为读锁，简称 S 锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
  - 排他锁【exclusive locks】又称为写锁，简称 X 锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。获取排他锁的事务可以对数据行读取和修改。
- 乐观锁
  - 乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作
  - 乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量
  - CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。
  - 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。



## 尽量避免死锁的出现

1. 获取锁的超时时间，至少能保证最差情况下，可以退出程
2. 使用低隔离级别
3. 设置按照同一顺序访问资源，类似于串行执行



## MySQL 如何做到高可用方案

MySQL 高可用，意味着不能一台 MySQL 出了问题，就不能访问了

1.  MySQL 高可用：分库分表，通过 MyCat 连接多个 MySQL
2. MyCat 也得高可用：Haproxy，连接多个 MyCat
3. Haproxy 也得高可用：通过 keepalived 辅助 Haproxy



